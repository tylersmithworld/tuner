<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Tuner</title>
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap" rel="stylesheet"/>
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden; background: #000;
      height: 100%; width: 100%;
      touch-action: none;
    }
    body { height: 100vh; width: 100vw; }
    canvas { display: block; background: #000; }
    #tune-btn {
      position: fixed; bottom: 32px; left: 50%; transform: translateX(-50%);
      padding: 14px 32px; border-radius: 32px; border: none;
      background: #ff7700; color: #fff; font-family: 'Bebas Neue', sans-serif;
      font-size: 26px; letter-spacing: 1.5px; cursor: pointer;
      box-shadow: 0 2px 16px #0008;
      z-index: 10;
      opacity: 0.98;
      transition: opacity 0.25s;
    }
    #tune-btn.hide { opacity: 0; pointer-events: none; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <button id="tune-btn">Tap to Tune</button>
  <script>
    const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const A4 = 440;
    const TUNE_WINDOW = 4;

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const tuneBtn = document.getElementById('tune-btn');
    let VERTICAL_RANGE = window.innerHeight * 0.4;

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      VERTICAL_RANGE = window.innerHeight * 0.4;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- Safe draw function that always shows background and line ---
    function drawUI(noteDisplay, inTune, centsValue, smoothCents) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      let cx = canvas.width / 2;
      let cy = canvas.height / 2;

      // Overlay logic
      if (noteDisplay && !inTune) {
        if (centsValue > TUNE_WINDOW) {
          // Sharp = yellow
          ctx.save();
          ctx.fillStyle = "rgba(255, 200, 30, 0.15)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.restore();
        } else if (centsValue < -TUNE_WINDOW) {
          // Flat = blue
          ctx.save();
          ctx.fillStyle = "rgba(30, 100, 255, 0.13)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.restore();
        }
      }

      // Always draw horizontal center line
      ctx.save();
      ctx.strokeStyle = "rgba(255,119,0,0.11)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, cy);
      ctx.lineTo(canvas.width, cy);
      ctx.stroke();
      ctx.restore();

      // Draw note only if inTune
      if (noteDisplay && inTune) {
        let offsetY = Math.max(-1, Math.min(1, smoothCents / 50)) * VERTICAL_RANGE;
        ctx.save();
        ctx.font = `${Math.floor(canvas.height * 0.18)}px 'Bebas Neue', sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "#13d35c";
        ctx.shadowBlur = 28;
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = "#13d35c";
        ctx.fillText(noteDisplay.name || "â€“", cx, cy + offsetY);

        // Octave and frequency display
        ctx.font = `${Math.floor(canvas.height * 0.04)}px 'Bebas Neue', sans-serif`;
        ctx.globalAlpha = 0.7;
        ctx.shadowBlur = 0;
        ctx.fillStyle = "#ff7700";
        ctx.fillText("Oct " + noteDisplay.octave + "  " + noteDisplay.freq.toFixed(1) + " Hz", cx, cy + offsetY + canvas.height * 0.12);
        ctx.restore();
      }
    }

    // --- Pitch detection ---
    let audioCtx, analyser, micStream, data, running = false;
    const bufLen = 2048;
    data = new Float32Array(bufLen);

    function autoCorrelate(buf, sampleRate) {
      let SIZE = buf.length;
      let rms = 0;
      for (let i = 0; i < SIZE; i++) rms += buf[i] * buf[i];
      rms = Math.sqrt(rms/SIZE);
      if (rms < 0.01) return -1;

      let r1 = 0, r2 = SIZE - 1, thres = 0.2;
      for (let i = 0; i < SIZE/2; i++) if (Math.abs(buf[i]) < thres) { r1 = i; break; }
      for (let i = 1; i < SIZE/2; i++) if (Math.abs(buf[SIZE-i]) < thres) { r2 = SIZE-i; break; }

      buf = buf.slice(r1, r2);
      SIZE = buf.length;

      let c = new Array(SIZE).fill(0);
      for (let i = 0; i < SIZE; i++)
        for (let j = 0; j < SIZE - i; j++)
          c[i] = c[i] + buf[j] * buf[j+i];

      let d = 0; while (d < SIZE - 1 && c[d] > c[d+1]) d++;
      let maxval = -1, maxpos = -1;
      for (let i = d; i < SIZE; i++) {
        if (c[i] > maxval) { maxval = c[i]; maxpos = i; }
      }
      let T0 = maxpos;
      if (T0 <= 0) return -1;
      let x1 = c[T0-1] || 0, x2 = c[T0], x3 = c[T0+1] || 0;
      let a = (x1 + x3 - 2*x2)/2;
      let b = (x3 - x1)/2;
      if (a) T0 = T0 - b/(2*a);
      let freq = sampleRate / T0;
      if (freq > 82 && freq < 1100) return freq;
      return -1;
    }

    function freqToNote(f) {
      const n = 12 * (Math.log2(f / A4));
      const noteNum = Math.round(n) + 57;
      const name = NOTE_NAMES[(noteNum + 12*10) % 12];
      const octave = Math.floor(noteNum / 12);
      const diff = n - Math.round(n);
      const cents = Math.floor(diff * 100);
      return { name, octave, cents: Math.floor((n - Math.round(n)) * 100), midi: noteNum };
    }

    // State
    let noteDisplay = null;
    let inTune = false, smoothCents = 0, centsValue = 0;

    function updatePitch() {
      if (!running) return;
      analyser.getFloatTimeDomainData(data);
      let freq = autoCorrelate(data, audioCtx.sampleRate);
      if (freq > 0) {
        let n = freqToNote(freq);
        noteDisplay = { ...n, freq };
        centsValue = n.cents;
        smoothCents += ((n.cents) - smoothCents) * 0.12;
        inTune = Math.abs(n.cents) < TUNE_WINDOW;
      } else {
        noteDisplay = null;
        centsValue = 0;
        smoothCents = 0;
        inTune = false;
      }
      setTimeout(updatePitch, 60);
    }

    function animate() {
      drawUI(noteDisplay, inTune, centsValue, smoothCents);
      if (running) requestAnimationFrame(animate);
      // Always at least background and line are drawn, even if not running
    }

    // Always show at least the line, even before mic access
    drawUI(null, false, 0, 0);

    tuneBtn.addEventListener('click', async () => {
      if (running) return;
      tuneBtn.classList.add('hide');
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = bufLen;
      try {
        micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        let src = audioCtx.createMediaStreamSource(micStream);
        src.connect(analyser);
        running = true;
        noteDisplay = null;
        animate();
        updatePitch();
      } catch (e) {
        alert('Mic access needed for tuner.');
        tuneBtn.classList.remove('hide');
      }
    });

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) running = false;
    });
  </script>
</body>
</html>
