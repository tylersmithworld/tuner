<script>
  // --- CONFIG ---
  const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  const A4 = 440;
  const TUNE_WINDOW = 4;      // tight green zone
  const VERTICAL_RANGE = window.innerHeight * 0.4;

  // --- ELEMENTS ---
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const tuneBtn = document.getElementById('tune-btn');

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  // --- PITCH DETECTION ---
  let audioCtx, analyser, micStream, data, running = false;
  const bufLen = 2048;
  data = new Float32Array(bufLen);

  function autoCorrelate(buf, sampleRate) {
    let SIZE = buf.length;
    let rms = 0;
    for (let i = 0; i < SIZE; i++) rms += buf[i] * buf[i];
    rms = Math.sqrt(rms/SIZE);
    if (rms < 0.01) return -1;

    let r1 = 0, r2 = SIZE - 1, thres = 0.2;
    for (let i = 0; i < SIZE/2; i++) if (Math.abs(buf[i]) < thres) { r1 = i; break; }
    for (let i = 1; i < SIZE/2; i++) if (Math.abs(buf[SIZE-i]) < thres) { r2 = SIZE-i; break; }

    buf = buf.slice(r1, r2);
    SIZE = buf.length;

    let c = new Array(SIZE).fill(0);
    for (let i = 0; i < SIZE; i++)
      for (let j = 0; j < SIZE - i; j++)
        c[i] = c[i] + buf[j] * buf[j+i];

    let d = 0; while (d < SIZE - 1 && c[d] > c[d+1]) d++;
    let maxval = -1, maxpos = -1;
    for (let i = d; i < SIZE; i++) {
      if (c[i] > maxval) { maxval = c[i]; maxpos = i; }
    }
    let T0 = maxpos;
    if (T0 <= 0) return -1;
    let x1 = c[T0-1] || 0, x2 = c[T0], x3 = c[T0+1] || 0;
    let a = (x1 + x3 - 2*x2)/2;
    let b = (x3 - x1)/2;
    if (a) T0 = T0 - b/(2*a);
    let freq = sampleRate / T0;
    if (freq > 82 && freq < 1100) return freq;
    return -1;
  }

  function freqToNote(f) {
    const n = 12 * (Math.log2(f / A4));
    const noteNum = Math.round(n) + 57;
    const name = NOTE_NAMES[(noteNum + 12*10) % 12];
    const octave = Math.floor(noteNum / 12);
    const diff = n - Math.round(n);
    const cents = Math.floor(diff * 100);
    return { name, octave, cents: Math.floor((n - Math.round(n)) * 100), midi: noteNum };
  }

  let noteDisplay = { name: '', octave: '', cents: 0, midi: 0, freq: 0 };
  let inTune = false, smoothCents = 0, showNote = false, centsValue = 0;

  function updatePitch() {
    if (!running) return;
    analyser.getFloatTimeDomainData(data);
    let freq = autoCorrelate(data, audioCtx.sampleRate);
    if (freq > 0) {
      let n = freqToNote(freq);
      noteDisplay = { ...n, freq };
      centsValue = n.cents;
      smoothCents += ((n.cents) - smoothCents) * 0.12;
      inTune = Math.abs(n.cents) < TUNE_WINDOW;
      showNote = inTune;
    } else {
      showNote = false;
      centsValue = 0;
    }
    setTimeout(updatePitch, 60);
  }

  tuneBtn.addEventListener('click', async () => {
    if (running) return;
    tuneBtn.classList.add('hide');
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = bufLen;
    try {
      micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      let src = audioCtx.createMediaStreamSource(micStream);
      src.connect(analyser);
      running = true;
      showNote = false;
      updatePitch();
      animate();
    } catch (e) {
      alert('Mic access needed for tuner.');
      tuneBtn.classList.remove('hide');
    }
  });

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    let cx = canvas.width / 2;
    let cy = canvas.height / 2;

    // Overlay logic
    if (!inTune && noteDisplay.name) {
      if (centsValue > TUNE_WINDOW) {
        // Sharp = yellow (RGBA)
        ctx.save();
        ctx.fillStyle = "rgba(255, 200, 30, 0.15)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
      } else if (centsValue < -TUNE_WINDOW) {
        // Flat = blue
        ctx.save();
        ctx.fillStyle = "rgba(30, 100, 255, 0.13)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
      }
    }

    // Subtle horizontal center line
    ctx.save();
    ctx.strokeStyle = "rgba(255,119,0,0.11)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(0, cy);
    ctx.lineTo(canvas.width, cy);
    ctx.stroke();
    ctx.restore();

    // Draw only when inTune (showNote)
    if (showNote) {
      let offsetY = Math.max(-1, Math.min(1, smoothCents / 50)) * VERTICAL_RANGE;
      ctx.save();
      ctx.font = `${Math.floor(canvas.height * 0.18)}px 'Bebas Neue', sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.shadowColor = "#13d35c";
      ctx.shadowBlur = 28;
      ctx.globalAlpha = 1.0;
      ctx.fillStyle = "#13d35c";
      ctx.fillText(noteDisplay.name || "â€“", cx, cy + offsetY);

      // Octave and frequency display (optional)
      ctx.font = `${Math.floor(canvas.height * 0.04)}px 'Bebas Neue', sans-serif`;
      ctx.globalAlpha = 0.7;
      ctx.shadowBlur = 0;
      ctx.fillStyle = "#ff7700";
      ctx.fillText("Oct " + noteDisplay.octave + "  " + noteDisplay.freq.toFixed(1) + " Hz", cx, cy + offsetY + canvas.height * 0.12);
      ctx.restore();
    }
    if (running) requestAnimationFrame(animate);
  }

  document.addEventListener('visibilitychange', () => {
    if (document.hidden) running = false;
  });
</script>
