<script>
  // --- CONFIG ---
  const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  const A4 = 440;
  const TUNE_WINDOW = 4;      // smaller = tighter green zone (even harder to hit!)
  const VERTICAL_RANGE = window.innerHeight * 0.4; // note travels up to ~40% of screen

  // --- ELEMENTS ---
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const tuneBtn = document.getElementById('tune-btn');

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  // --- PITCH DETECTION ---
  let audioCtx, analyser, micStream, data, running = false;
  const bufLen = 2048;
  data = new Float32Array(bufLen);

  function autoCorrelate(buf, sampleRate) {
    let SIZE = buf.length;
    let rms = 0;
    for (let i = 0; i < SIZE; i++) rms += buf[i] * buf[i];
    rms = Math.sqrt(rms/SIZE);
    if (rms < 0.01) return -1;

    let r1 = 0, r2 = SIZE - 1, thres = 0.2;
    for (let i = 0; i < SIZE/2; i++) if (Math.abs(buf[i]) < thres) { r1 = i; break; }
    for (let i = 1; i < SIZE/2; i++) if (Math.abs(buf[SIZE-i]) < thres) { r2 = SIZE-i; break; }

    buf = buf.slice(r1, r2);
    SIZE = buf.length;

    let c = new Array(SIZE).fill(0);
    for (let i = 0; i < SIZE; i++)
      for (let j = 0; j < SIZE - i; j++)
        c[i] = c[i] + buf[j] * buf[j+i];

    let d = 0; while (d < SIZE - 1 && c[d] > c[d+1]) d++;
    let maxval = -1, maxpos = -1;
    for (let i = d; i < SIZE; i++) {
      if (c[i] > maxval) { maxval = c[i]; maxpos = i; }
    }
    let T0 = maxpos;
    if (T0 <= 0) return -1;
    let x1 = c[T0-1] || 0, x2 = c[T0], x3 = c[T0+1] || 0;
    let a = (x1 + x3 - 2*x2)/2;
    let b = (x3 - x1)/2;
    if (a) T0 = T0 - b/(2*a);
    let freq = sampleRate / T0;
    if (freq > 82 && freq < 1100) return freq;
    return -1;
  }

  function freqToNote(f) {
    const n = 12 * (Math.log2(f / A4));
    const noteNum = Math.round(n) + 57;
    const name = NOTE_NAMES[(noteNum + 12*10) % 12];
    const octave = Math.floor(noteNum / 12);
    const diff = n - Math.round(n);
    const cents = Math.floor(diff * 100);
    return { name, octave, cents: Math.floor((n - Math.round(n)) * 100), midi: noteNum };
  }

  let noteDisplay = { name: '', octave: '', cents: 0, midi: 0, freq: 0 };
  let inTune = false, lastFreq = 0, smoothCents = 0, everDetected = false;

  function updatePitch() {
    if (!running) return;
    analyser.getFloatTimeDomainData(data);
    let freq = autoCorrelate(data, audioCtx.sampleRate);
    if (freq > 0) {
      everDetected = true;
      lastFreq = freq;
      let n = freqToNote(freq);
      noteDisplay = { ...n, freq };
      smoothCents += ((n.cents) - smoothCents) * 0.12;
      inTune = Math.abs(n.cents) < TUNE_WINDOW;
    }
    setTimeout(updatePitch, 60);
  }

  tuneBtn.addEventListener('click', async () => {
    if (running) return;
    tuneBtn.classList.add('hide');
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = bufLen;
    try {
      micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      let src = audioCtx.createMediaStreamSource(micStream);
      src.connect(analyser);
      running = true;
      everDetected = false;
      updatePitch();
      animate();
    } catch (e) {
      alert('Mic access needed for tuner.');
      tuneBtn.classList.remove('hide');
    }
  });

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    let cx = canvas.width / 2;
    let cy = canvas.height / 2;

    // Light, subtle horizontal center line
    ctx.save();
    ctx.strokeStyle = "rgba(255,119,0,0.11)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(0, cy);
    ctx.lineTo(canvas.width, cy);
    ctx.stroke();
    ctx.restore();

    // Compute offset; map +/- 50 cents to the whole VERTICAL_RANGE (for big movement)
    let offsetY = Math.max(-1, Math.min(1, smoothCents / 50)) * VERTICAL_RANGE;

    // Opacity: always 0.7 unless in the green zone, then 1.0
    let useAlpha = inTune ? 1.0 : 0.7;

    // "Don’t start green": only green if (a) inTune AND (b) everDetected a real note
    let showGreen = inTune && everDetected;

    // Draw note
    ctx.save();
    ctx.font = `${Math.floor(canvas.height * 0.18)}px 'Bebas Neue', sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.shadowColor = showGreen ? "#13d35c" : "#000";
    ctx.shadowBlur = showGreen ? 28 : 0;
    ctx.globalAlpha = useAlpha;
    ctx.fillStyle = showGreen ? "#13d35c" : "#fff";
    ctx.fillText(noteDisplay.name || "–", cx, cy + offsetY);

    // Octave and frequency display (optional)
    ctx.font = `${Math.floor(canvas.height * 0.04)}px 'Bebas Neue', sans-serif`;
    ctx.globalAlpha = useAlpha * 0.7;
    ctx.shadowBlur = 0;
    ctx.fillStyle = "#ff7700";
    if (noteDisplay.octave !== '' && noteDisplay.freq)
      ctx.fillText("Oct " + noteDisplay.octave + "  " + noteDisplay.freq.toFixed(1) + " Hz", cx, cy + offsetY + canvas.height * 0.12);

    ctx.restore();

    if (running) requestAnimationFrame(animate);
  }

  document.addEventListener('visibilitychange', () => {
    if (document.hidden) running = false;
  });
</script>

</body>
</html>
